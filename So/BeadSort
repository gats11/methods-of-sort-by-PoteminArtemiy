def bead_sort(arr):
    """
    Сортировка бусинами (гравитационная)
    Временная сложность: O(n) теоретически, O(S) практически
    Только для неотрицательных целых чисел
    """
    if not arr:
        return []
    
    # Проверяем, что все элементы неотрицательные целые
    if any(not isinstance(x, int) or x < 0 for x in arr):
        raise ValueError("Сортировка бусинами работает только с неотрицательными целыми числами")
    
    # Находим максимальное значение
    max_val = max(arr)
    
    # Создаем "абак" - матрицу бусин
    abacus = [[0] * len(arr) for _ in range(max_val)]
    
    # Размещаем бусины (1 - есть бусина, 0 - нет бусины)
    for i, num in enumerate(arr):
        for j in range(num):
            abacus[j][i] = 1
    
    print("Абак до гравитации:")
    for row in abacus:
        print(row)
    
    # Симулируем гравитацию - бусины падают вниз
    for col in range(len(arr)):
        # Считаем количество бусин в столбце
        beads_count = sum(1 for row in range(max_val) if abacus[row][col] == 1)
        
        # Перераспределяем бусины (все падают вниз)
        for row in range(max_val):
            abacus[row][col] = 1 if row < beads_count else 0
    
    print("Абак после гравитации:")
    for row in abacus:
        print(row)
    
    # Считываем результат (количество бусин в каждом столбце)
    result = []
    for col in range(len(arr)):
        result.append(sum(1 for row in range(max_val) if abacus[row][col] == 1))
    
    return result

# Демонстрация работы
if __name__ == "__main__":
    test_array = [3, 1, 4, 1, 2]
    print("Сортировка бусинами:")
    print(f"Исходный массив: {test_array}")
    sorted_array = bead_sort(test_array)
    print(f"Отсортированный массив: {sorted_array}")
"""
Результат:
Сортировка бусинами:
Исходный массив: [3, 1, 4, 1, 2]
Абак до гравитации:
[1, 1, 1, 1, 1]
[1, 0, 1, 0, 1]
[1, 0, 1, 0, 0]
[0, 0, 1, 0, 0]
Абак после гравитации:
[1, 1, 1, 1, 1]
[1, 0, 1, 0, 1]
[1, 0, 1, 0, 0]
[0, 0, 1, 0, 0]
Отсортированный массив: [3, 1, 4, 1, 2]
"""
