# Анализ алгоритмов сортировки и поиска

## Алгоритмы сортировки

### Блочная (корзинная) сортировка

**Определение:** Алгоритм распределяет элементы массива на несколько блоков (корзин) в зависимости от диапазона их значений, затем каждая корзина сортируется отдельно.

**Объяснение работы:**
1. **Определяется количество корзин и диапазон значений**  
   `num_buckets = len(arr)`  
   `min_val, max_val = min(arr), max(arr)`  
   `bucket_range = (max_val - min_val) / num_buckets`

2. **Каждый элемент распределяется в соответствующую корзину**  
   `index = int((num - min_val) / bucket_range)`  
   `buckets[index].append(num)`

3. **Корзины сортируются индивидуально (сортировкой вставками)**  
   `insertion_sort(bucket)`

4. **Отсортированные корзины объединяются в результирующий массив**  
   `result.extend(bucket)`

**Оценка временной сложности:** O(n + k)

**Объяснение сложности:** В лучшем случае при равномерном распределении данных достигается линейная сложность O(n). В худшем случае (все элементы в одной корзине) сложность составляет O(n²).

### Блинная сортировка

**Определение:** Алгоритм основан на операции переворота префикса массива.

**Объяснение работы:**
1. **Находится максимальный элемент в неотсортированной части**  
   `max_idx = arr.index(max(arr[:size]))`

2. **Переворачивается подмассив до позиции максимального элемента**  
   `flip(arr, max_idx)`

3. **Переворачивается весь подмассив для перемещения максимума в конец**  
   `flip(arr, size - 1)`

4. **Процесс повторяется для оставшейся неотсортированной части**  
   `for size in range(n, 1, -1):`

**Оценка временной сложности:** O(n²)

**Объяснение сложности:** Для каждого элемента выполняется поиск максимума (O(n)) и два переворота (O(n)), что в сумме дает O(n²).

### Сортировка бусинами (гравитационная)

**Определение:** Алгоритм моделирует поведение бусин, падающих под действием гравитации.

**Объяснение работы:**
1. **Элементы представляются как ряды бусин на стержнях**  
   `abacus = [[0] * len(arr) for _ in range(max_val)]`  
   `abacus[j][i] = 1`

2. **Бусины "падают" вниз под действием гравитации**  
   `beads_count = sum(1 for row in range(max_val) if abacus[row][col] == 1)`  
   `abacus[row][col] = 1 if row < beads_count else 0`

3. **Результат считывается сверху вниз**  
   `result.append(sum(1 for row in range(max_val) if abacus[row][col] == 1))`

**Оценка временной сложности:** O(n) теоретически, O(S) практически

**Объяснение сложности:** Теоретически линейная, но на практике зависит от значений элементов, где S - сумма всех элементов.

## Алгоритмы поиска

### Поиск скачками

**Определение:** Оптимизация линейного поиска с "прыжками" через блоки элементов.

**Объяснение работы:**
1. **Массив делится на блоки фиксированного размера**  
   `step = int(math.sqrt(n))`

2. **Выполняются прыжки через блоки для быстрого сужения диапазона**  
   `while prev < n and arr[min(step, n) - 1] < target:`  
   `prev = step`  
   `step += int(math.sqrt(n))`

3. **В найденном блоке выполняется линейный поиск**  
   `for i in range(prev, min(step, n)):`  
   `if arr[i] == target: return i`

**Оценка временной сложности:** O(√n)

**Объяснение сложности:** Оптимальный размер блока - √n, что дает минимальное количество сравнений.

### Экспоненциальный поиск

**Определение:** Сочетает последовательный и бинарный поиск.

**Объяснение работы:**
1. **Диапазон поиска расширяется экспоненциально**  
   `i = 1`  
   `while i < n and arr[i] <= target:`  
   `i *= 2`

2. **Когда граница найдена, выполняется бинарный поиск в диапазоне**  
   `return binary_search(arr, target, i // 2, min(i, n - 1))`

3. **Бинарный поиск делит диапазон пополам**  
   `mid = (low + high) // 2`  
   `if arr[mid] == target: return mid`

**Оценка временной сложности:** O(log n)

**Объяснение сложности:** Экспоненциальное расширение занимает O(log i), где i - позиция элемента, плюс бинарный поиск O(log n).

### Тернарный поиск

**Определение:** Делит диапазон поиска на три части.

**Объяснение работы:**
1. **Диапазон делится на три равные части**  
   `mid1 = low + (high - low) // 3`  
   `mid2 = high - (high - low) // 3`

2. **Сравнивается искомый элемент с граничными значениями**  
   `if arr[mid1] == target: return mid1`  
   `if arr[mid2] == target: return mid2`

3. **Поиск продолжается в соответствующей трети**  
   `if target < arr[mid1]: return recursive_ternary(low, mid1 - 1)`  
   `elif target > arr[mid2]: return recursive_ternary(mid2 + 1, high)`  
   `else: return recursive_ternary(mid1 + 1, mid2 - 1)`

**Оценка временной сложности:** O(log₃ n)

**Объяснение сложности:** На каждом шаге поисковое пространство уменьшается в 3 раза.
